# **Finding Lane Lines on the Road** 


---

# Overview

The goals / steps of this project are the following:
* Make a pipeline that finds lane lines on the road
* Reflect on your work in a written report


[//]: # (Image References)

[image_0]: ./examples/grayscale.jpg "Grayscale"
[image_1]: ./test_images_output/steps/solidYellowCurve_img_ori.jpg "img_ori"
[image_2]: ./test_images_output/steps/solidYellowCurve_img_open.jpg "img_open"
[image_3]: ./test_images_output/steps/solidYellowCurve_img_mor.jpg "img_mor"
[image_4]: ./test_images_output/steps/solidYellowCurve_img_mor_blur.jpg "img_mor_blur"
[image_5]: ./test_images_output/steps/solidYellowCurve_bi_edge.jpg "bi_edge"
[image_6]: ./test_images_output/steps/solidYellowCurve_bi_edge_roi.jpg "bi_edge_roi"
[image_7]: ./test_images_output/steps/solidYellowCurve_color_line_drawn.jpg "color_line_drawn"
[image_8]: ./test_images_output/steps/solidYellowCurve_img_proc.jpg "img_proc"

---

# Reflection

## 1. Describe your pipeline. As part of the description, explain how you modified the draw_lines() function.

There are roughly 5 steps in my pipeline:
- Morphological openrations on color image
- Low-pass filtering and Canny
- Selecting ROI
- Applying Hough-line algorithm 
- Blending lines on image

![alt text][image_1]
Fig. 1 The original color image

**1. Morphological Openration on Color Image**

This step is composed by two sub-steps:
- Morphological openning on original image to get the local average of intensity/color, 
- Subtracting the original image with the local average

The kernel size of the openning operation is set to be wider than the lane line, so that the lane line will not be smoothed out. This resulted in removal of effect by lightening/shadow and difference in road color (which occured in challenge.mp4) as shown in the following figures.

![alt text][image_2]
Fig. 2 The local intensity/color generated by openning

![alt text][image_3]
Fig. 3 The resulted color image after subtracting the opened image by local intensity/color

**2. Low-pass Filtering and Canny**

This step can also be devided into two sub-steps:
- Low-pass filtering the color image by Gaussian kernel
- Apply Canny to the color image for calculating edges from all channel

The differnce between the method describe here and the one described in lecture is that here I apply canny directly on 3-channel color image rather than 1-channel gray image. This is effective for detected the "edges" of color blocks that have similar intensity (such as the one in challenge.mp4)

![alt text][image_4]
Fig. 4 The low-pass filtered color image

![alt text][image_5]
Fig. 5 Edges detected by canny

**3. Selecting ROI**

Currently, without further technique or insight of the problem, the simplest to remove edges other than the lane-lines we want is by selecting the region of intreast (ROI). The lane-lines are normally located at the lower triagular region on the firure if the car goes straight at the center of lane. After selecting the ROI, the resulted edges are shown in the following figure.

![alt text][image_6]
Fig. 6 Edges detected inside the ROI

**4. Applying Hough-line Algorithm**

There are three main works to be done in this step:
- Using Hough-line transform to find the end-points of line-segments
- Classify and statistically summarize the line segments as parameters of linear equations of left/right lane
- Draw lines on a blank canvas 

With the clear edges from the previous step, the Hough-line algorithm can precisely find out end points of each line-segment. The next challenge is to classify the lines as well as combine all the line-segments at the same side to a single line. This method will be described below.

![alt text][image_7]
Fig. 7 Lines drawn on a blank canvas, where the magenta lines are line segments detected by Hough-line algorithm, and the red thick lines are the estimated left/right lane lines

**5. Blending Lines on Image**

The final step is to blend the original color image with the lane-line image from the previous step and return as final result. The blending using the following equation

$$P_{out,i,j} = 0.8 P_{original,i,j} + 1.0 P_{lines, i,j},$$ 
where the $P_{out,i,j}$, $P_{original,i,j}$, and $P_{lines,i,j}$ are pixel at $(i,j)$ of output image, original image, and line image repectively.

![alt text][image_8]
Fig. 8 The final result: blending the original image with the line-image. 





### **Estimating Right/Left Lane Line form Line Segments**

In order to draw a single line on the left and right lanes, I rewrite the draw_lines() function as draw_lines_thick_2() function. In draw_lines_thick_2() function, 





## 2. Identify potential shortcomings with your current pipeline


The current pipeline comes with many shortcomings. Some straightly come form the assumptions it makes, including:

- The prior knowledge of ROI and slop of lane only work if the car is already straight on the lane. When the car change lanes or deviate from lane, the algorithm might fail.
- If the lane is not straight, i.e. a turn, the estimated line fitted on it is somewhat meaningless

Another are the limitations of the algorithm I used:

- The lane classification uses only slop of line segments to determin whether the line segment belongs to right, left, or noise, which can easily generate wrong result. For example, the short line with small possitive slop on the left will also be classified as right lane.
- The line fitting 

## 3. Suggest possible improvements to your pipeline

A possible improvement would be to ...

Another potential improvement could be to ...
