# **Finding Lane Lines on the Road** 


---

# Overview

The goals / steps of this project are the following:
* Make a pipeline that finds lane lines on the road
* Reflect on your work in a written report


[//]: # (Image References)

[image_0]: ./examples/grayscale.jpg "Grayscale"
[image_1]: ./test_images_output/steps/solidYellowCurve_img_ori.jpg "img_ori"
[image_2]: ./test_images_output/steps/solidYellowCurve_img_open.jpg "img_open"
[image_3]: ./test_images_output/steps/solidYellowCurve_img_mor.jpg "img_mor"
[image_4]: ./test_images_output/steps/solidYellowCurve_img_mor_blur.jpg "img_mor_blur"
[image_5]: ./test_images_output/steps/solidYellowCurve_bi_edge.jpg "bi_edge"
[image_6]: ./test_images_output/steps/solidYellowCurve_bi_edge_roi.jpg "bi_edge_roi"
[image_7]: ./test_images_output/steps/solidYellowCurve_color_line_drawn.jpg "color_line_drawn"
[image_8]: ./test_images_output/steps/solidYellowCurve_img_proc.jpg "img_proc"

---

# Reflection

## 1. Describe your pipeline. As part of the description, explain how you modified the draw_lines() function.

There are roughly 5 steps in my pipeline:
- Morphological openrations on color image
- Low-pass filtering and Canny
- Selecting ROI
- Applying Hough-line algorithm 
- Blending lines on image

![alt text][image_1]
Fig. 1 The original color image

**1. Morphological Openration on Color Image**

This step is composed by two sub-steps:
- Morphological openning on original image to get the local average of intensity/color, 
- Subtracting the original image with the local average

The kernel size of the openning operation is set to be wider than the lane line, so that the lane line will not be smoothed out. This resulted in removal of effect by lightening/shadow and difference in road color (which occured in challenge.mp4) as shown in the following figures.

![alt text][image_2]
Fig. 2 The local intensity/color generated by openning

![alt text][image_3]
Fig. 3 The resulted color image after subtracting the opened image by local intensity/color

**2. Low-pass Filtering and Canny**

This step can also be devided into two sub-steps:
- Low-pass filtering the color image by Gaussian kernel
- Apply Canny to the color image for calculating edges from all channel

The differnce between the method describe here and the one described in lecture is that here I apply canny directly on 3-channel color image rather than 1-channel gray image. This is effective for detected the "edges" of color blocks that have similar intensity (such as the one in challenge.mp4)

![alt text][image_4]
Fig. 4 The low-pass filtered color image

![alt text][image_5]
Fig. 5 Edges detected by canny

**3. Selecting ROI**

Currently, without further technique or insight of the problem, the simplest to remove edges other than the lane-lines we want is by selecting the region of intreast (ROI). The lane-lines are normally located at the lower triagular region on the firure if the car goes straight at the center of lane. After selecting the ROI, the resulted edges are shown in the following figure.

![alt text][image_6]
Fig. 6 Edges detected inside the ROI

**4. Applying Hough-line Algorithm**

There are three main works to be done in this step:
- Using Hough-line transform to find the end-points of line-segments
- Classify and statistically summarize the line segments as parameters of linear equations of left/right lane
- Draw lines on a blank canvas 

With the clear edges from the previous step, the Hough-line algorithm can precisely find out end points of each line-segment. The next challenge is to classify the lines as well as combine all the line-segments at the same side to a single line. This method will be described below.

![alt text][image_7]
Fig. 7 Lines drawn on a blank canvas, where the magenta lines are line segments detected by Hough-line algorithm, and the red thick lines are the estimated left/right lane lines

**5. Blending Lines on Image**

The final step is to blend the original color image with the lane-line image from the previous step and return as final result. The blending using the following equation

$$P_{out,i,j} = 0.8 P_{original,i,j} + 1.0 P_{lines, i,j},$$ 
where the $P_{out,i,j}$, $P_{original,i,j}$, and $P_{lines,i,j}$ are pixel at $(i,j)$ of output image, original image, and line image repectively.

![alt text][image_8]
Fig. 8 The final result: blending the original image with the line-image. 





### **Estimating Right/Left Lane Line form Line Segments**

In order to draw a single line on the left and right lanes, I rewrite the draw_lines() function as draw_lines_thick_2() function. 

In draw_lines_thick_2() function, I use simple ideas to generate the two lines we want.

- Classify the line segments from Hough-line algorithm by slop
- Fit a line according to end-points of line segments in each class, while weighting each endpoints propotional to the square of the length of the line segment.

The first step classify each line segment into three classes:
- Right lane: slop > 0 and |slop| < 3
- Left lane: slop < 0 and |slop| < 3
- Noise: |slop| >= 3

Note that the slop is defined in the following equation

$$slop = \dfrac{x_2-x_1}{y_2-y_1},$$

which is opposite to the normal definitions. Since that the lane line is prone to be vertical line in image, this definition is more numerically stable than the normal definition in this case.

In second step, points of line segment in the same class are fit to a line. Each point are weight propotional to the length of line segment since it would be more likely to be the correct line for long segments. I use the numpy.polyfit() function to fit the line. The problem with this function is that it can not give weight for each sample, so I simply duplicate each sample as many times as their weight.

## 2. Identify potential shortcomings with your current pipeline


The current pipeline comes with many shortcomings. Some straightly come form the assumptions it makes, including:

- The prior knowledge of ROI and slop of lane only work if the car is already straight on the lane. When the car change lanes or deviate from lane, the algorithm might fail.
- If the lane is not straight, i.e. a turn, the estimated line fitted on it is somewhat meaningless

Another are the limitations of the algorithm I used:

- The hard-coded thresholds in canny and Hough might not generally worked, especially when the lightening condition changed.
- The perspective geometry of photography limit the usage of morphological operations, since things appear larger when they were close and smaller when ithey were far.
- The lane classification uses only slop of line segments to determin whether the line segment belongs to right, left, or noise, which can easily generate wrong result. For example, the short line with small possitive slop on the left will also be classified as right lane.
- The line fitting algorithm is highly sensitive to outliers form wrong classification mentioned above, which can even generate lines with opposite slop, e.g. the slop of the estimation for right line become negative. 

## 3. Suggest possible improvements to your pipeline

- One possible solution for the threshold problems can be adaptive image enhancement method which adjust the average intensitive of image to the same value no matter the scene is dark or light. Another may be using statistical properties of each image to determine the threshoulds.
- One possible solution for the line classification and fitting problem is to use clustering algorithm like k-means to separate the line segments and produce better fit. Another possible solution for classification and fitting problem is using random sample consensus (RANSAC) to find inliers.

